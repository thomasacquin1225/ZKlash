{
  "version": 3,
  "sources": ["../../@noir-lang/backend_barretenberg/lib/esm/base64_decode.js", "../../@noir-lang/backend_barretenberg/lib/esm/serialize.js", "../../@noir-lang/backend_barretenberg/lib/esm/index.js"],
  "sourcesContent": ["// Since this is a simple function, we can use feature detection to\n// see if we are in the nodeJs environment or the browser environment.\nexport function base64Decode(input) {\n    if (typeof Buffer !== 'undefined') {\n        // Node.js environment\n        return Buffer.from(input, 'base64');\n    }\n    else if (typeof atob === 'function') {\n        // Browser environment\n        return Uint8Array.from(atob(input), (c) => c.charCodeAt(0));\n    }\n    else {\n        throw new Error('No implementation found for base64 decoding.');\n    }\n}\n", "import { decompressSync as gunzip } from 'fflate';\nimport { base64Decode } from './base64_decode.js';\n// Converts bytecode from a base64 string to a Uint8Array\nexport function acirToUint8Array(base64EncodedBytecode) {\n    const compressedByteCode = base64Decode(base64EncodedBytecode);\n    return gunzip(compressedByteCode);\n}\n", "/* eslint-disable  @typescript-eslint/no-explicit-any */\nimport { acirToUint8Array } from './serialize.js';\nexport class BarretenbergBackend {\n    // These type assertions are used so that we don't\n    // have to initialize `api` and `acirComposer` in the constructor.\n    // These are initialized asynchronously in the `init` function,\n    // constructors cannot be asynchronous which is why we do this.\n    api;\n    acirComposer;\n    acirUncompressedBytecode;\n    numberOfThreads = 1;\n    constructor(acirCircuit, numberOfThreads = 1) {\n        const acirBytecodeBase64 = acirCircuit.bytecode;\n        this.numberOfThreads = numberOfThreads;\n        this.acirUncompressedBytecode = acirToUint8Array(acirBytecodeBase64);\n    }\n    async instantiate() {\n        if (!this.api) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            //@ts-ignore\n            const { Barretenberg, RawBuffer, Crs } = await import('@aztec/bb.js');\n            const api = await Barretenberg.new(this.numberOfThreads);\n            const [_exact, _total, subgroupSize] = await api.acirGetCircuitSizes(this.acirUncompressedBytecode);\n            const crs = await Crs.new(subgroupSize + 1);\n            await api.commonInitSlabAllocator(subgroupSize);\n            await api.srsInitSrs(new RawBuffer(crs.getG1Data()), crs.numPoints, new RawBuffer(crs.getG2Data()));\n            this.acirComposer = await api.acirNewAcirComposer(subgroupSize);\n            this.api = api;\n        }\n    }\n    // Generate an outer proof. This is the proof for the circuit which will verify\n    // inner proofs and or can be seen as the proof created for regular circuits.\n    //\n    // The settings for this proof are the same as the settings for a \"normal\" proof\n    // ie one that is not in the recursive setting.\n    async generateFinalProof(decompressedWitness) {\n        const makeEasyToVerifyInCircuit = false;\n        return this.generateProof(decompressedWitness, makeEasyToVerifyInCircuit);\n    }\n    // Generates an inner proof. This is the proof that will be verified\n    // in another circuit.\n    //\n    // This is sometimes referred to as a recursive proof.\n    // We avoid this terminology as the only property of this proof\n    // that matters, is the fact that it is easy to verify in another\n    // circuit. We _could_ choose to verify this proof in the CLI.\n    //\n    // We set `makeEasyToVerifyInCircuit` to true, which will tell the backend to\n    // generate the proof using components that will make the proof\n    // easier to verify in a circuit.\n    async generateIntermediateProof(witness) {\n        const makeEasyToVerifyInCircuit = true;\n        return this.generateProof(witness, makeEasyToVerifyInCircuit);\n    }\n    async generateProof(decompressedWitness, makeEasyToVerifyInCircuit) {\n        await this.instantiate();\n        const proof = await this.api.acirCreateProof(this.acirComposer, this.acirUncompressedBytecode, decompressedWitness, makeEasyToVerifyInCircuit);\n        return proof;\n    }\n    // Generates artifacts that will be passed to a circuit that will verify this proof.\n    //\n    // Instead of passing the proof and verification key as a byte array, we pass them\n    // as fields which makes it cheaper to verify in a circuit.\n    //\n    // The proof that is passed here will have been created using the `generateInnerProof`\n    // method.\n    //\n    // The number of public inputs denotes how many public inputs are in the inner proof.\n    async generateIntermediateProofArtifacts(proof, numOfPublicInputs = 0) {\n        await this.instantiate();\n        const proofAsFields = await this.api.acirSerializeProofIntoFields(this.acirComposer, proof, numOfPublicInputs);\n        // TODO: perhaps we should put this in the init function. Need to benchmark\n        // TODO how long it takes.\n        await this.api.acirInitVerificationKey(this.acirComposer);\n        // Note: If you don't init verification key, `acirSerializeVerificationKeyIntoFields`` will just hang on serialization\n        const vk = await this.api.acirSerializeVerificationKeyIntoFields(this.acirComposer);\n        return {\n            proofAsFields: proofAsFields.map((p) => p.toString()),\n            vkAsFields: vk[0].map((vk) => vk.toString()),\n            vkHash: vk[1].toString(),\n        };\n    }\n    async verifyFinalProof(proof) {\n        const makeEasyToVerifyInCircuit = false;\n        const verified = await this.verifyProof(proof, makeEasyToVerifyInCircuit);\n        return verified;\n    }\n    async verifyIntermediateProof(proof) {\n        const makeEasyToVerifyInCircuit = true;\n        return this.verifyProof(proof, makeEasyToVerifyInCircuit);\n    }\n    async verifyProof(proof, makeEasyToVerifyInCircuit) {\n        await this.instantiate();\n        await this.api.acirInitVerificationKey(this.acirComposer);\n        return await this.api.acirVerifyProof(this.acirComposer, proof, makeEasyToVerifyInCircuit);\n    }\n    async destroy() {\n        if (!this.api) {\n            return;\n        }\n        await this.api.destroy();\n    }\n}\n"],
  "mappings": "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",
  "names": ["vk"]
}
