import {
  decompressSync
} from "./chunk-FTKT6EYC.js";
import {
  __publicField
} from "./chunk-E3EO7R6B.js";

// node_modules/@noir-lang/backend_barretenberg/lib/esm/base64_decode.js
function base64Decode(input) {
  if (typeof Buffer !== "undefined") {
    return Buffer.from(input, "base64");
  } else if (typeof atob === "function") {
    return Uint8Array.from(atob(input), (c) => c.charCodeAt(0));
  } else {
    throw new Error("No implementation found for base64 decoding.");
  }
}

// node_modules/@noir-lang/backend_barretenberg/lib/esm/serialize.js
function acirToUint8Array(base64EncodedBytecode) {
  const compressedByteCode = base64Decode(base64EncodedBytecode);
  return decompressSync(compressedByteCode);
}

// node_modules/@noir-lang/backend_barretenberg/lib/esm/index.js
var BarretenbergBackend = class {
  constructor(acirCircuit, numberOfThreads = 1) {
    // These type assertions are used so that we don't
    // have to initialize `api` and `acirComposer` in the constructor.
    // These are initialized asynchronously in the `init` function,
    // constructors cannot be asynchronous which is why we do this.
    __publicField(this, "api");
    __publicField(this, "acirComposer");
    __publicField(this, "acirUncompressedBytecode");
    __publicField(this, "numberOfThreads", 1);
    const acirBytecodeBase64 = acirCircuit.bytecode;
    this.numberOfThreads = numberOfThreads;
    this.acirUncompressedBytecode = acirToUint8Array(acirBytecodeBase64);
  }
  async instantiate() {
    if (!this.api) {
      const { Barretenberg, RawBuffer, Crs } = await import("./browser-GLGSNURN.js");
      const api = await Barretenberg.new(this.numberOfThreads);
      const [_exact, _total, subgroupSize] = await api.acirGetCircuitSizes(this.acirUncompressedBytecode);
      const crs = await Crs.new(subgroupSize + 1);
      await api.commonInitSlabAllocator(subgroupSize);
      await api.srsInitSrs(new RawBuffer(crs.getG1Data()), crs.numPoints, new RawBuffer(crs.getG2Data()));
      this.acirComposer = await api.acirNewAcirComposer(subgroupSize);
      this.api = api;
    }
  }
  // Generate an outer proof. This is the proof for the circuit which will verify
  // inner proofs and or can be seen as the proof created for regular circuits.
  //
  // The settings for this proof are the same as the settings for a "normal" proof
  // ie one that is not in the recursive setting.
  async generateFinalProof(decompressedWitness) {
    const makeEasyToVerifyInCircuit = false;
    return this.generateProof(decompressedWitness, makeEasyToVerifyInCircuit);
  }
  // Generates an inner proof. This is the proof that will be verified
  // in another circuit.
  //
  // This is sometimes referred to as a recursive proof.
  // We avoid this terminology as the only property of this proof
  // that matters, is the fact that it is easy to verify in another
  // circuit. We _could_ choose to verify this proof in the CLI.
  //
  // We set `makeEasyToVerifyInCircuit` to true, which will tell the backend to
  // generate the proof using components that will make the proof
  // easier to verify in a circuit.
  async generateIntermediateProof(witness) {
    const makeEasyToVerifyInCircuit = true;
    return this.generateProof(witness, makeEasyToVerifyInCircuit);
  }
  async generateProof(decompressedWitness, makeEasyToVerifyInCircuit) {
    await this.instantiate();
    const proof = await this.api.acirCreateProof(this.acirComposer, this.acirUncompressedBytecode, decompressedWitness, makeEasyToVerifyInCircuit);
    return proof;
  }
  // Generates artifacts that will be passed to a circuit that will verify this proof.
  //
  // Instead of passing the proof and verification key as a byte array, we pass them
  // as fields which makes it cheaper to verify in a circuit.
  //
  // The proof that is passed here will have been created using the `generateInnerProof`
  // method.
  //
  // The number of public inputs denotes how many public inputs are in the inner proof.
  async generateIntermediateProofArtifacts(proof, numOfPublicInputs = 0) {
    await this.instantiate();
    const proofAsFields = await this.api.acirSerializeProofIntoFields(this.acirComposer, proof, numOfPublicInputs);
    await this.api.acirInitVerificationKey(this.acirComposer);
    const vk = await this.api.acirSerializeVerificationKeyIntoFields(this.acirComposer);
    return {
      proofAsFields: proofAsFields.map((p) => p.toString()),
      vkAsFields: vk[0].map((vk2) => vk2.toString()),
      vkHash: vk[1].toString()
    };
  }
  async verifyFinalProof(proof) {
    const makeEasyToVerifyInCircuit = false;
    const verified = await this.verifyProof(proof, makeEasyToVerifyInCircuit);
    return verified;
  }
  async verifyIntermediateProof(proof) {
    const makeEasyToVerifyInCircuit = true;
    return this.verifyProof(proof, makeEasyToVerifyInCircuit);
  }
  async verifyProof(proof, makeEasyToVerifyInCircuit) {
    await this.instantiate();
    await this.api.acirInitVerificationKey(this.acirComposer);
    return await this.api.acirVerifyProof(this.acirComposer, proof, makeEasyToVerifyInCircuit);
  }
  async destroy() {
    if (!this.api) {
      return;
    }
    await this.api.destroy();
  }
};
export {
  BarretenbergBackend
};
//# sourceMappingURL=@noir-lang_backend_barretenberg.js.map
